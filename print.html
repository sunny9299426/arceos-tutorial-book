<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ArceOS Tutorial Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">ArceOS Tutorial Book</a></li><li class="chapter-item expanded "><a href="ch01-00.html"><strong aria-hidden="true">1.</strong> 第一章 概述</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.html"><strong aria-hidden="true">1.1.</strong> 操作系统概述</a></li><li class="chapter-item expanded "><a href="ch01-02.html"><strong aria-hidden="true">1.2.</strong> ArceOS 概述</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.html"><strong aria-hidden="true">2.</strong> 第二章 实验设计与准备</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.html"><strong aria-hidden="true">2.1.</strong> OS 环境配置</a></li><li class="chapter-item expanded "><a href="ch02-02.html"><strong aria-hidden="true">2.2.</strong> Rust 开发环境配置</a></li><li class="chapter-item expanded "><a href="ch02-03.html"><strong aria-hidden="true">2.3.</strong> Qemu 模拟器安装</a></li><li class="chapter-item expanded "><a href="ch02-04.html"><strong aria-hidden="true">2.4.</strong> 其他工具安装</a></li><li class="chapter-item expanded "><a href="ch02-05.html"><strong aria-hidden="true">2.5.</strong> 验证环境</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.html"><strong aria-hidden="true">3.</strong> 第三章 Hello,ArceOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.html"><strong aria-hidden="true">3.1.</strong> 设计与实现</a></li><li class="chapter-item expanded "><a href="ch03-02.html"><strong aria-hidden="true">3.2.</strong> 本章实践与总结</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.html"><strong aria-hidden="true">4.</strong> 第四章 内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.html"><strong aria-hidden="true">4.1.</strong> 设计与实现</a></li><li class="chapter-item expanded "><a href="ch04-02.html"><strong aria-hidden="true">4.2.</strong> 本章实践与总结</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.html"><strong aria-hidden="true">5.</strong> 第五章 任务调度</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.html"><strong aria-hidden="true">5.1.</strong> 建立通用调度框架</a></li><li class="chapter-item expanded "><a href="ch05-02.html"><strong aria-hidden="true">5.2.</strong> 协作式调度机制与示例</a></li><li class="chapter-item expanded "><a href="ch05-03.html"><strong aria-hidden="true">5.3.</strong> 抢占式调度机制与示例</a></li><li class="chapter-item expanded "><a href="ch05-04.html"><strong aria-hidden="true">5.4.</strong> 本章实践与总结</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.html"><strong aria-hidden="true">6.</strong> 第六章 设备与驱动</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.html"><strong aria-hidden="true">6.1.</strong> 设计与实现</a></li><li class="chapter-item expanded "><a href="ch06-02.html"><strong aria-hidden="true">6.2.</strong> 本章实践与总结</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.html"><strong aria-hidden="true">7.</strong> 第七章 文件系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.html"><strong aria-hidden="true">7.1.</strong> 设计与实现</a></li><li class="chapter-item expanded "><a href="ch07-02.html"><strong aria-hidden="true">7.2.</strong> 本章实践与总结</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.html"><strong aria-hidden="true">8.</strong> 第八章 网络</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.html"><strong aria-hidden="true">8.1.</strong> 设计与实现</a></li><li class="chapter-item expanded "><a href="ch08-02.html"><strong aria-hidden="true">8.2.</strong> 本章实践与总结</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.html"><strong aria-hidden="true">9.</strong> 第九章 应用支持库</a></li><li class="chapter-item expanded "><a href="ch10-00.html"><strong aria-hidden="true">10.</strong> 第十章 多核支持- SMP</a></li><li class="chapter-item expanded "><a href="ch11-00.html"><strong aria-hidden="true">11.</strong> 第十一章 总结和展望</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01.html"><strong aria-hidden="true">11.1.</strong> 设计思想</a></li><li class="chapter-item expanded "><a href="ch11-02.html"><strong aria-hidden="true">11.2.</strong> 未来发展</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ArceOS Tutorial Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rcore-os/arceos-tutorial-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="arceos-tutorial-book"><a class="header" href="#arceos-tutorial-book">ArceOS tutorial book</a></h1>
<h2 id="自己动手写组件化操作系统自顶向下自底向上的方法"><a class="header" href="#自己动手写组件化操作系统自顶向下自底向上的方法">自己动手写组件化操作系统：自顶向下+自底向上的方法</a></h2>
<p>本教程假设读者了解操作系统基本概念和原理，具有常用的 Linux 系统使用经验，并且会使用 Rust 语言编写简单程序。
如果读者不熟悉操作系统和 Rust 语言，希望以自底向上方法从零构建操作系统，[rCore Tutorial Book v3] 可能是更好的选择。</p>
<p>如果你准备好了，让我们开始吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>本教程编写的思路与目标：实验结合理论</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="操作系统概述"><a class="header" href="#操作系统概述">操作系统概述</a></h2>
<h3 id="os-在计算机体系结构中的位置和作用"><a class="header" href="#os-在计算机体系结构中的位置和作用">OS 在计算机体系结构中的位置和作用</a></h3>
<h3 id="os-的主要模式"><a class="header" href="#os-的主要模式">OS 的主要模式</a></h3>
<p>操作系统内核是计算机系统的核心，负责管理硬件资源，包括处理器、内存、磁盘存储等，并为运行在操作系统上的应用程序提供一组接口（系统调用）来访问这些资源。操作系统内核架构是指操作系统内核设计和实现的方式。以下是几种常见的操作系统内核架构：</p>
<h4 id="宏内核monolithic-kernel"><a class="header" href="#宏内核monolithic-kernel">宏内核（Monolithic Kernel）</a></h4>
<p>宏内核将操作系统的所有服务，如设备驱动、文件系统、网络协议栈和进程调度等都集成在一个大的内核中，运行在内核空间。这种设计使得各个模块可以直接相互通信，因此性能较好。然而，宏内核的缺点是任何一个故障都可能导致整个系统崩溃。另外，由于所有模块都紧密耦合在一起，修改或添加功能也比较困难。Linux 和 UNIX 就是采用宏内核设计的例子。</p>
<h4 id="微内核micro-kernel"><a class="header" href="#微内核micro-kernel">微内核（Micro Kernel）</a></h4>
<p>微内核只保留最基本的、必要的服务在内核空间，如进程间通信、内存管理和基本的I/O操作等，其他高级服务例如设备驱动、文件系统等都运行在用户空间。这样的设计使得系统更加稳定，因为即使一个服务出现故障也不会影响到整个系统，同时也使得系统更易于维护和扩展。但在性能方面，由于需要频繁地进行用户空间与内核空间之间的上下文切换，微内核的性能通常低于宏内核。Minix 和 QNX 是采用微内核设计的例子。</p>
<h4 id="单内核unikernel"><a class="header" href="#单内核unikernel">单内核（Unikernel）</a></h4>
<p>单内核是一种新兴的内核架构，它将应用程序和内核捆绑在一起形成一个单一的可执行映像，该映像可以直接运行在虚拟机或裸机上。单内核适用于云计算和物联网环境，它的优点是体积小，启动快，但对开发者的编程要求较高。单内核（Unikernel）架构有如下特点:</p>
<ol>
<li>
<p>单一镜像：将应用程序代码与操作系统核心功能合并到一个单一的可执行镜像中。这个镜像包含了应用程序所需的所有组件，包括网络协议、文件系统和设备驱动等。因此，每个 Unikernel 实例都是一个独立的、自包含的单元。</p>
</li>
<li>
<p>定制性：根据应用程序的需求进行定制，只包含必要的组件和库。这种定制性减少了不必要的功能和复杂性，在资源受限的环境下更加高效。</p>
</li>
<li>
<p>轻量级：相比传统操作系统，内存占用更小，启动时间更短。由于只包含必要的组件，它可以更好地适应嵌入式系统、虚拟化环境和云计算平台等资源受限的场景。</p>
</li>
<li>
<p>性能效率：通过减少不必要的软件层和系统调用，减少了性能开销，使得应用程序可以更高效地运行。</p>
</li>
</ol>
<p>总的来说，Unikernel 是一种精简、定制化的操作系统构建技术，旨在提供更高的性能、更低的资源消耗和更强的安全性。它适用于各种场景，包括嵌入式系统、云计算平台和容器化环境等。</p>
<p>为了更好的理解 Unikernel，我们对 Unikernel（单内核）、 Micro Kernel（微内核）、Monolithic Kernel（宏内核）进行对比。</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Unikernel（单内核）</th><th>Micro Kernel（微内核）</th><th>Monolithic Kernel（宏内核）</th></tr></thead><tbody>
<tr><td>架构</td><td>将应用程序、操作系统内核、必要的组件紧密集成在一起，以创建一个高度定制化和最小化的镜像。</td><td>采用模块化设计，将操作系统的核心功能最小化，额外的功能和服务实现为用户空间的服务模块。</td><td>将各种功能和服务集成到一个单体内核中，如进程管理、内存管理、文件系统、网络协议栈等。</td></tr>
<tr><td>功能分配</td><td>包含应用程序所需的最小化操作系统功能和库。</td><td>包含基本的操作系统功能，如进程管理、内存管理和进程间通信，而其他功能如文件系统、网络协议栈等被实现为用户空间的服务模块。</td><td>包含大量的功能和服务，这些功能和服务直接运行在内核空间，具有较高的集成性和内核级别的访问权限。</td></tr>
<tr><td>性能</td><td>镜像小，启动速度快，没有额外的组件和系统调用，具有更高的性能和较低的资源消耗。</td><td>将功能模块化并移至用户空间，其性能相对较低。模块之间需要进行消息传递和系统调用，会引入额外的开销。</td><td>内核和服务的紧密集成，有较高的性能</td></tr>
<tr><td>特权级</td><td>同一地址空间同一特权级。</td><td>只有进程管理和进程间通信在内核态</td><td>所有硬件操作在内核态</td></tr>
<tr><td>代表系统</td><td>ArceOS、Unikraft、MirageOS、IncludeOS</td><td>QNX、MINIX、L4微内核系列</td><td>Linux、Windows</td></tr>
</tbody></table>
</div><img src="./img/img1_3.png" alt="img1_3" style="zoom: 33%;" />
<h3 id="历史上各阶段的代表性-os-及其特点"><a class="header" href="#历史上各阶段的代表性-os-及其特点">历史上各阶段的代表性 OS 及其特点</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h2 id="arceos-概述"><a class="header" href="#arceos-概述">ArceOS 概述</a></h2>
<h3 id="背景"><a class="header" href="#背景">背景</a></h3>
<p>计算机发展到今天，新型硬件层出不穷，应用对性能和安全的需求也越来越⾼。而作为底层支撑的操作系统却发展滞后，无论是以 Linux，Windows 为代表的通用操作系统，还是如 RT-Thread、FreeRTOS 等实时操作系统，都存在着各种各样的问题，很难满足硬件和应用对操作系统的发展需求。</p>
<img src=".\img\img1_4.png" alt="image-20230904105516339" style="zoom:50%;" />
<p>⽬前操作系统存在的主要问题：</p>
<ul>
<li>
<p>安全性问题，主要是内存安全，各种漏洞越来增多；</p>
<img src=".\img\img1_5.png" alt="image-20230904105736242" style="zoom:50%;" />
</li>
<li>
<p>⾯向通⽤场景，现在的操作系统大多是通用操作系统，为了适应各种各样的场景，需要要做多方面的权衡，从而导致操作系统越来越臃肿、笨重；</p>
</li>
<li>
<p>有些操作系统虽然采用了一些组件化设计思想，但是组件之间的耦合度高，导致组件难以重⽤；</p>
<img src=".\img\img1_6.png" alt="image-20230904105825026" style="zoom: 67%;" />
</li>
<li>
<p>基于现有的复杂的操作系统，开发应用的门槛较高，复杂性也越来越高。</p>
</li>
</ul>
<h3 id="目标与特点"><a class="header" href="#目标与特点">目标与特点</a></h3>
<p>ArceOS 是一个实验性的，基于 unikernel 的组件化操作系统， 主要面向的领域是 AIoT，即人工智能+物联网领域，对于安全性、高性能和应用的要求比较高。在设计时，采用 Rust 语言开发操作系统内核，通过结合软硬件协同优化达到如下目标：</p>
<ul>
<li>安全（基于 Rust 语言）</li>
<li>高并发支持和高吞吐量（异步协程）</li>
<li>实时性（用户态中断机制）</li>
<li>支持 POSIX 接口（兼容生态）</li>
<li>内核模块可按应用场景开发（便捷精简开发）</li>
</ul>
<p>具有以下特性：</p>
<ol>
<li>组件化：以组件粒度组装适应各种应用需求的操作系统。</li>
<li>以应用为中心(unikernel)：面向应用，依照依赖链，选出最小的必要组件集合，构造操作系统。</li>
<li>组件区分系统相关和系统无关：识别具有通用功能的组件，可以为其它操作系统所复用。</li>
<li>利用 Rust 机制：以 crate 对应组件，trait 对应接口，dependencies+features 的方式对组件进行组织。</li>
</ol>
<h3 id="总体结构"><a class="header" href="#总体结构">总体结构</a></h3>
<p>ArceOS 从架构上包含如下几层：</p>
<ul>
<li>ArceOS crates，通用的基础库，系统无关，为 modules 实现提供支持</li>
<li>ArceOS modules，系统相关，只为 ArceOS 服务的组件库</li>
<li>ArceOS API，ArceOS 对应用层提供服务的 API，包括面向 RUST 应用程序的 API 、面向 C 应用程序的 API</li>
<li>ArceOS ulib</li>
<li>User AppS</li>
</ul>
<img src=".\assets\ArceOS.svg" />
<p>ArceOS 从形态上具有以下特点：</p>
<ul>
<li>单应用</li>
<li>单地址空间</li>
<li>单特权级</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="实验设计与准备"><a class="header" href="#实验设计与准备">实验设计与准备</a></h2>
<h3 id="概述-1"><a class="header" href="#概述-1">概述</a></h3>
<p>实验引导原理的学习方法：一步一步构建组件化UnikernelOS，每一步把理论介绍与实验过程结合起来，与通过实践理解OS原理，掌握一定的OS构造方法。</p>
<p>Unikernel对用户表现为单应用，OS则以库的形式嵌入应用。从两个视角介绍实验过程：</p>
<ul>
<li>
<p>应用层：介绍一个应用迭代升级的过程，每次增加功能和增强特性。</p>
</li>
<li>
<p>OS层：对应每次的应用迭代，OS需要扩展的功能组件，和该组件的原理与实现。</p>
</li>
</ul>
<p>应用选择mini-redis-server，该应用完成时的目标；相应的OS具备的功能。</p>
<p>图：双层总体流程图 箭头连接&lt;预留img2_1.png&gt;</p>
<h3 id="预备知识"><a class="header" href="#预备知识">预备知识</a></h3>
<ul>
<li>
<p>Rust系统编程</p>
</li>
<li>
<p>RISC-V体系结构与实验</p>
</li>
<li>
<p>MiniRedis的基本功能与客户端使用，基于std标准库</p>
</li>
</ul>
<h3 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h3>
<ul>
<li><a href="https://sunny9299426.github.io/arceos-tutorial-book/ch02-01.html">OS 环境配置</a></li>
<li><a href="https://sunny9299426.github.io/arceos-tutorial-book/ch02-02.html">Rust 开发环境配置</a></li>
<li><a href="https://sunny9299426.github.io/arceos-tutorial-book/ch02-03.html">QEMU 模拟器安装</a></li>
<li><a href="https://sunny9299426.github.io/arceos-tutorial-book/ch02-04.html">其他工具安装</a></li>
<li><a href="https://sunny9299426.github.io/arceos-tutorial-book/ch02-05.html">验证环境</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="os-环境配置"><a class="header" href="#os-环境配置">OS 环境配置</a></h2>
<p>目前实验内容可支持在 <a href="https://cdimage.ubuntu.com/releases/">Ubuntu操作系统</a> 上进行操作。</p>
<p>对于 Windows10/11 的用户可以通过系统内置的 WSL2 虚拟机（请不要使用 WSL1）来安装 Ubuntu 22.04，步骤如下：</p>
<ul>
<li>
<p>升级 Windows 10/11 到最新版（Windows 10 版本 18917 或以后的内部版本）。注意，如果不是 Windows 10/11 专业版，可能需要手动更新，在微软官网上下载。升级之后， 可以在 PowerShell 中输入 <code>winver</code> 命令来查看内部版本号。</p>
</li>
<li>
<p>「Windows 设置 &gt; 更新和安全 &gt; Windows 预览体验计划」处选择加入 “Dev 开发者模式”。</p>
</li>
<li>
<p>以管理员身份打开 PowerShell 终端并输入以下命令：</p>
<pre><code class="language-powershell"># 启用 Windows 功能：“适用于 Linux 的 Windows 子系统”
&gt;&gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart

# 启用 Windows 功能：“已安装的系统虚拟机平台”
&gt;&gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

# &lt;Distro&gt; 改为对应从微软应用商店安装的 Linux 版本名，比如：`wsl --set-version Ubuntu 2`
# 如果你没有提前从微软应用商店安装任何 Linux 版本，请跳过此步骤
&gt;&gt; wsl --set-version &lt;Distro&gt; 2

# 设置默认为 WSL 2，如果 Windows 版本不够，这条命令会出错
&gt;&gt; wsl --set-default-version 2

# 启用运行 WSL 并安装 Linux 的 Ubuntu 发行版所需的功能，根据向导设置用户名和密码
&gt;&gt; wsl --install
</code></pre>
</li>
</ul>
<blockquote>
<p><font color=blue><strong>注解👉</strong></font></p>
<p>由于时间问题我们主要在 Ubuntu22.04  on x86-64 上进行了测试，后面的配置也是基于此环境进行。你也可以在其他 Linux 发行版上进行实验，基本上不会出现太大的问题。如果遇到了问题的话，请在本节的讨论区中留言，我们会尽量帮助解决。</p>
</blockquote>
<p>参考：<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10#step-4---download-the-linux-kernel-update-package">使用 WSL 在 Windows 上安装 Linux</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust-开发环境配置"><a class="header" href="#rust-开发环境配置">Rust 开发环境配置</a></h2>
<p>首先安装 Rust 版本管理器 rustup 和 Rust 包管理器 cargo，这里我们用官方的安装脚本来安装：</p>
<p><code>curl https://sh.rustup.rs -sSf | sh</code></p>
<p>如果通过官方的脚本下载失败了，可以在浏览器的地址栏中输入 <a href="https://sh.rustup.rs/">https://sh.rustup.rs</a> 来下载脚本，在本地运行即可。</p>
<p>如果官方的脚本在运行时出现了网络速度较慢的问题，可选地可以通过修改 rustup 的镜像地址（修改为中国科学技术大学的镜像服务器）来加速：</p>
<pre><code class="language-bash">export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static
export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup
curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>或者使用 tuna 源来加速 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/rustup/">参见 rustup 帮助</a>：</p>
<pre><code class="language-bash">export RUSTUP_DIST_SERVER=https://mirrors.tuna.edu.cn/rustup
export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.edu.cn/rustup/rustup
curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>或者也可以通过在运行前设置命令行中的科学上网代理来实现：</p>
<pre><code class="language-bash"># e.g. Shadowsocks 代理，请根据自身配置灵活调整下面的链接
export https_proxy=http://127.0.0.1:1080
export http_proxy=http://127.0.0.1:1080
export ftp_proxy=http://127.0.0.1:1080
</code></pre>
<p>安装完成后，我们可以重新打开一个终端来让之前设置的环境变量生效。我们也可以手动将环境变量设置应用到当前终端，只需要输入以下命令：</p>
<p><code>source $HOME/.cargo/env</code></p>
<p>接下来，我们可以确认一下我们正确安装了 Rust 工具链：</p>
<p><code>rustc --version</code></p>
<p>可以看到当前安装的工具链的版本。</p>
<p><code>rustc 1.70.0 (90c541806 2023-05-31)</code></p>
<blockquote>
<p><font color=red><strong>警告⚠️</strong></font></p>
<p>目前适用于操作系统实验开发的 rustc 编译器的版本为 1.73.0，你可以选择更新版本的 rustc 编译器。但注意<strong>只能用 rustc 的 nightly 类型的版本</strong>。</p>
</blockquote>
<p>可通过如下命令安装 rustc 的 nightly 版本，并把该版本设置为 rustc 的默认版本。</p>
<pre><code class="language-bash">rustup install nightly
rustup default nightly
</code></pre>
<p>再次确认一下我们安装了正确的 rustc  版本：</p>
<pre><code class="language-bash">rustc --version
rustc 1.73.0-nightly (33a2c2487 2023-07-12)
</code></pre>
<p>我们最好把软件包管理器 cargo 所用的软件包镜像地址 crates.io 也换成中国科学技术大学的镜像服务器来加速三方库的下载。我们打开（如果没有就新建） <code>~/.cargo/config</code> 文件，并把内容修改为：</p>
<pre><code>[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;
replace-with = 'ustc'
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;
</code></pre>
<p>同样，也可以使用 tuna 源 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/crates.io-index.git/">参见 crates.io 帮助</a>：</p>
<pre><code>[source.crates-io]
replace-with = 'tuna'

[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;
</code></pre>
<p>接下来安装一些Rust相关的软件包</p>
<pre><code class="language-bash">rustup target add riscv64gc-unknown-none-elf
rustup component add llvm-tools-preview
rustup component add rust-src
</code></pre>
<blockquote>
<p><font color=red><strong>警告⚠️</strong></font></p>
<p>如果你更换了另外一个 rustc 编译器（必须是 nightly 版的），<strong>需要重新安装上述 rustc 所需软件包</strong>。ArceOS 仓库中的 <code>Makefile</code> 包含了这些工具的安装，如果你使用 <code>make run</code> 也可以不手动安装。</p>
</blockquote>
<p>至于 Rust 开发环境，推荐 JetBrains Clion + Rust插件 或者 Visual Studio Code 搭配 rust-analyzer 和 RISC-V Support 插件。</p>
<blockquote>
<p><font color=blue><strong>注解👉</strong></font></p>
<p>JetBrains Clion 付费商业软件，但对于学生和教师，只要在 JetBrains 网站注册账号，可以享受一定期限（半年左右）的免费使用的福利。</p>
<ul>
<li>Visual Studio Code 是开源软件，不用付费就可使用。</li>
<li>当然，采用 VIM，Emacs 等传统的编辑器也是没有问题的。</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="qemu-模拟器安装"><a class="header" href="#qemu-模拟器安装">QEMU 模拟器安装</a></h2>
<p>我们需要使用 QEMU 7.0 版本进行实验，低版本的 QEMU 可能导致框架代码不能正常运行。而很多 Linux 发行版的软件包管理器默认软件源中的 QEMU 版本过低，因此我们需要从源码手动编译安装 QEMU 模拟器软件。下面以 Ubuntu 22.04 上的安装流程为例进行说明：</p>
<p>首先我们安装依赖包，获取 QEMU 源代码并手动编译：</p>
<pre><code class="language-bash"># 安装编译所需的依赖包
sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \
              gawk build-essential bison flex texinfo gperf libtool patchutils bc \
              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev \
              git tmux python3 python3-pip ninja-build
# 下载源码包
# 如果下载速度过慢可以使用我们提供的百度网盘链接：https://pan.baidu.com/s/1dykndFzY73nqkPL2QXs32Q
# 提取码：jimc
wget https://download.qemu.org/qemu-7.0.0.tar.xz
# 解压
tar xvJf qemu-7.0.0.tar.xz
# 编译安装并配置 RISC-V 支持
cd qemu-7.0.0
./configure --target-list=riscv64-softmmu,riscv64-linux-user  # 如果要支持图形界面，可添加 &quot; --enable-sdl&quot; 参数
make -j$(nproc)
</code></pre>
<blockquote>
<p><font color=blue><strong>注解👉</strong></font>  </p>
<p>注意，上面的依赖包可能并不完全，比如在 Ubuntu 18.04 上：</p>
<ul>
<li>出现 <code>ERROR: pkg-config binary 'pkg-config' not found</code> 时，可以安装 <code>pkg-config</code> 包；</li>
<li>出现 <code>ERROR: glib-2.48 gthread-2.0 is required to compile QEMU</code> 时，可以安装 <code>libglib2.0-dev</code> 包；</li>
<li>出现 <code>ERROR: pixman &gt;= 0.21.8 not present</code> 时，可以安装 <code>libpixman-1-dev</code> 包。</li>
</ul>
</blockquote>
<p>另外一些 Linux 发行版编译 QEMU 的依赖包可以从 <a href="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html#prerequisites">这里</a> 找到。</p>
<p>之后我们可以在同目录下 <code>sudo make install</code> 将 QEMU 安装到 <code>/usr/local/bin</code> 目录下，但这样经常会引起冲突。个人来说更习惯的做法是，编辑 <code>~/.bashrc</code> 文件（如果使用的是默认的 <code>bash</code> 终端），在文件的末尾加入几行：</p>
<pre><code class="language-bash"># 请注意，/path/to是qemu-7.0.0 的父目录，应调整为实际的安装位置
export PATH=$PATH:/path/to/qemu-7.0.0/build
</code></pre>
<p>随后即可在当前终端 <code>source ~/.bashrc</code> 更新系统路径，或者直接重启一个新的终端。</p>
<p>此时我们可以确认 QEMU 的版本：</p>
<pre><code class="language-bash">qemu-system-riscv64 --version
qemu-riscv64 --version
</code></pre>
<blockquote>
<p><font color=red><strong>警告⚠️</strong></font></p>
<p>请尽量不要安装 <code>qemu-kvm</code> ，这可能会导致我们的框架无法正常运行。另外，我们仅在 Qemu 7.0.0 版本上进行了测试，请尽量不要切换到其他版本。</p>
</blockquote>
<h3 id="q--a"><a class="header" href="#q--a">Q &amp; A</a></h3>
<p>1、当安装编译所需的依赖包出现 Package xxx is not available, but is referred to by another package 错误时，可以尝试更新系统软件源，执行如下命令：</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get upgrade
</code></pre>
<p>2、wsl 系统 Ubuntu-20.04，执行<code>make -j($nproc)</code> 命令时，$nproc 应该要设置成（小于等于）实际的 cpu 物理内核数，如果用逻辑内核会导致 wsl 卡死。</p>
<p>3、在 PC 机上安装 Ubuntu，编译 qemu，提示 python's ensurepip 找不到，可以尝试执行如下命令：</p>
<pre><code>apt-get install python3-venv
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="其他工具安装"><a class="header" href="#其他工具安装">其他工具安装</a></h2>
<p>本节主要介绍 arceos 编译所需的依赖工具的安装。</p>
<p>为了使用 objdump、objcopy 工具，我们首先需要安装名为 cargo-binutils 的命令行工具集：</p>
<pre><code class="language-bash">cargo install cargo-binutils
</code></pre>
<p>为了编译运行 C 应用程序，安装 <code>libclang-dev</code>：</p>
<pre><code class="language-bash">sudo apt install libclang-dev
</code></pre>
<p>下载并安装 <code>cross-musl-based</code>工具链：</p>
<pre><code class="language-bash"># download
wget https://musl.cc/aarch64-linux-musl-cross.tgz
wget https://musl.cc/riscv64-linux-musl-cross.tgz
wget https://musl.cc/x86_64-linux-musl-cross.tgz
# install
tar zxf aarch64-linux-musl-cross.tgz
tar zxf riscv64-linux-musl-cross.tgz
tar zxf x86_64-linux-musl-cross.tgz
# exec below command in bash OR add below info in ~/.bashrc
export PATH=`pwd`/x86_64-linux-musl-cross/bin:`pwd`/aarch64-linux-musl-cross/bin:`pwd`/riscv64-linux-musl-cross/bin:$PATH
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="验证环境"><a class="header" href="#验证环境">验证环境</a></h2>
<p>本节介绍如何验证实验环境配置的正确与否。</p>
<ol>
<li>
<p>执行如下命令，获取 ArceOS 源码包：</p>
<p><code>git clone https://github.com/rcore-os/arceos.git</code></p>
</li>
<li>
<p>进入arceos目录，执行如下命令，编译并运行 helloworld unikernel：</p>
<p><code>make ARCH=riscv64 A=apps/helloworld run</code></p>
<p>其中，</p>
<p>ARCH 指定 CPU 体系架构，目前支持选项：<code>riscv64</code>, <code>aarch64</code>，<code>x86_64</code>。</p>
<p>A 指定用户程序的相对路径。</p>
</li>
</ol>
<p><img src="./img/2_2.png" alt="image-20230712163420462" /></p>
<p>到这里，恭喜你完成了实验环境的配置，可以开始阅读教程的正文部分了！</p>
<h3 id="q--a-1"><a class="header" href="#q--a-1">Q &amp; A</a></h3>
<p>当代码跑不起来的时候，可以尝试：</p>
<ul>
<li>分支是否与 原版仓库（而非 fork 出来的仓库）的对应分支同步。如不同步的话考虑通过 <code>git pull</code> 进行更新。注：这是因为 Rust 的版本更迭较快，如不及时更新的话曾经能正常运行的代码也会无法运行。</li>
<li>项目根目录下的 <code>rust-toolchain</code> 非常重要，它代表整个项目采用的 Rust 工具链版本。请务必保持其与原版仓库对应分支一致。</li>
<li>通过 <code>make clean</code> 或者 <code>cargo clean</code> 删除构建产物，并重新 <code>make run</code> 。注：出现这样的问题通常说明框架的构建脚本存在 bug，可以提 issue。</li>
</ul>
<p>如果怀疑遇到了网络问题，可以检查：</p>
<ul>
<li>请按照本章说明进行 Rust 安装和 crates.io 镜像配置。通常情况下能够解决 Rust 工具链更新和下载已发布到 crates.io 上库的问题。</li>
</ul>
<!--
- 如果发现在试图从 github 上下载下述几个库的时候卡死，可以修改 `arceos` 目录下的 `Cargo.toml` 替换为 gitee 上的镜像。例如，将：

  > ```toml
  > riscv = { git = "https://github.com/rcore-os/riscv", features = ["inline-asm"] }
  > ```
  
  替换为：
  
  > ```toml
  > riscv = { git = "https://gitee.com/rcore-os/riscv", features = ["inline-asm"] }
  > ```
--><div style="break-before: page; page-break-before: always;"></div><h2 id="helloarceos"><a class="header" href="#helloarceos">Hello,ArceOS</a></h2>
<p>通常，我们在学习一门新的编程语言时，接触的第一个示例程序就是 helloworld，当一名新的程序员清除完一切障碍顺利抵达 helloworld 时，他的内心体验到的不仅仅是一种成功的喜悦，更重要的是，他正在亲身经历一个跨越历史的时刻。各位，你还记得你第一次写的 helloworld 吗？</p>
<p>这一章，我们将沿袭前人之路，以 helloworld 来开启沟通 ArceOS 世界的历程。我们将通过从零开始设计实现一个 helloworld unikernel，来建立 ArceOS 的基本框架，并识别出其中的一些核心组件，从而感受 ArceOS 的理念、特性。</p>
<h3 id="目标"><a class="header" href="#目标">目标</a></h3>
<ol>
<li>从最简单的 HelloWorld 开始，分析建立框架与核心组件；</li>
<li>支持标准输出和 Log，了解 features 作用。</li>
</ol>
<img src="./img/img3_1.png" alt="image-20230905151307734" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h2 id="设计与实现"><a class="header" href="#设计与实现">设计与实现</a></h2>
<h3 id="迭代步骤"><a class="header" href="#迭代步骤">迭代步骤</a></h3>
<img src="./img/img3_2.png" alt="image-20230905151445642" style="zoom: 33%;" />
<h3 id="示例流程riscv64"><a class="header" href="#示例流程riscv64">示例流程（riscv64）</a></h3>
<img src="./img/img3_3.png" alt="image-20230905151554560" style="zoom:50%;" />
<h4 id="引导过程示例-axhalriscv64"><a class="header" href="#引导过程示例-axhalriscv64">引导过程示例: axhal(riscv64)</a></h4>
<img src="./img/img3_4.png" alt="image-20230905151803155" style="zoom: 50%;" />
<h4 id="引导过程示例-axruntime"><a class="header" href="#引导过程示例-axruntime">引导过程示例: axruntime</a></h4>
<img src="./img/img3_5.png" alt="image-20230905152234898" style="zoom:50%;" />
<img src="./img/img3_6.png" alt="image-20230905152308892" style="zoom:50%;" />
<img src="./img/img3_7.png" alt="image-20230905152347065" style="zoom:50%;" />
<h4 id="app引导完成转入运行"><a class="header" href="#app引导完成转入运行">app引导完成转入运行</a></h4>
<p>应用启动，并基于运行环境提供的各种功能，完成自身的逻辑计算。对于 Helloworld，仅仅需要借助 ulib 中 axstd::println 完成打印输出。</p>
<img src="./img/img3_8.png" alt="image-20230905152554161" style="zoom:50%;" />
<h4 id="日志级别控制与-features"><a class="header" href="#日志级别控制与-features">日志级别控制与 features</a></h4>
<p>在编译并运行 helloworld 时，可以指定 LOG 环境变量，以输出不同级别的日志。</p>
<pre><code>make LOG=info run
</code></pre>
<p>这是通过 features 传递，改变 kernel 行为的具体方法。可以通过三种方式指定 features：</p>
<img src="./img/img3_9.png" alt="image-20230905161958548" style="zoom:50%;" />
<h3 id="附录-相关组件"><a class="header" href="#附录-相关组件">附录 相关组件</a></h3>
<ul>
<li>
<h4 id="axhal-"><a class="header" href="#axhal-"><code>axhal</code> ：</a></h4>
<ul>
<li>模块源码位置：<a href="https://github.com/rcore-os/arceos/tree/main/modules/axhal">modules/axhal</a></li>
<li>模块描述： ArceOS 的硬件抽象层，负责为不同操作平台提供统一的 API。它为指定的操作平台进行引导和初始化过程，并在硬件上提供有用的操作。当前主要支持 pc-x86<code>、</code>qemu-virt-riscv<code>、</code>qemu-virt-aarch64` 等平台。</li>
</ul>
</li>
<li>
<h4 id="axruntime"><a class="header" href="#axruntime"><code>axruntime</code>：</a></h4>
<ul>
<li>
<p>模块源码位置：<a href="(https://github.com/rcore-os/arceos/tree/main/modules/axruntime)">modules/axruntime</a></p>
</li>
<li>
<p>模块描述：在进入应用程序的 main 函数之前执行一些初始化操作， 根据所选择的 feature 执行相对应的初始化过程。</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="本章实践与总结"><a class="header" href="#本章实践与总结">本章实践与总结</a></h2>
<h3 id="练习"><a class="header" href="#练习">练习</a></h3>
<h3 id="实验"><a class="header" href="#实验">实验</a></h3>
<p>题目：仿照println宏，增加一个新的宏println_prefix</p>
<p>要求：只能修改ulib/axstd/src/macros.rs，执行verify脚本验证a0通过。</p>
<p>预期输出：</p>
<p>Hello, world！</p>
<p>Stdout: Hello, world！[2]</p>
<p>[ArceOS Tutorial]: A0 okay! </p>
<p>提示：无。</p>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<p>v0.1 建立最基本的框架：核心组件axhal、axruntime、api、ulib以及上层应用组件。</p>
<p>后续版本在该基本框架的基础上，通过扩展功能组件(虚线部分)，扩展OS能力特性。</p>
<img src="./img/img3_10.png" alt="image-20230907105509230" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h2 id="内存管理"><a class="header" href="#内存管理">内存管理</a></h2>
<h3 id="目标-1"><a class="header" href="#目标-1">目标</a></h3>
<ol>
<li>物理内存布局</li>
<li>分页功能</li>
<li>内存分配框架和初始化</li>
<li>内存分配算法 tlsf, buddy, slab。</li>
</ol>
<p><img src="./img/img4_1.png" alt="image-20230908093104691" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="设计与实现-1"><a class="header" href="#设计与实现-1">设计与实现</a></h2>
<h3 id="物理内存布局"><a class="header" href="#物理内存布局">物理内存布局</a></h3>
<img src="./img/img4_2.png" alt="image4-2" style="zoom:50%;" />
<h3 id="分页--功能抽象和对应组件"><a class="header" href="#分页--功能抽象和对应组件">分页 – 功能抽象和对应组件</a></h3>
<img src="./img/img4_3.png" alt="image4_3" style="zoom:50%;" />
<p>分页启用分两个阶段：早期启用(必须)和后期重建映射(可选) 。</p>
<h4 id="分页阶段1--早期启用必须"><a class="header" href="#分页阶段1--早期启用必须">分页阶段1 – 早期启用(必须)</a></h4>
<h5 id="机制"><a class="header" href="#机制">机制</a></h5>
<p>内核启动的早期，采用规定的恒等映射方式。但是只映射一部分物理空间。</p>
<p>目标：完成Paging切换后，建立从虚拟空间0xffff_ffc0_8000_0000 ~ 0xffff_ffc0_8000_0000到物理空间0x8000_0000~0xC000_0000 的映射，范围1G。</p>
<p><strong>两步完成Paging切换：</strong></p>
<ol>
<li>恒等映射保证虚拟空间与物理空间有一个相等范围的地址空间映射(0x80000000~0xC0000000)。切换前后地址范围不变，但地址空间已经从物理空间切换到虚拟空间；</li>
<li>给指令指针寄存器pc，栈寄存器sp等加偏移，在图中该偏移是0xffff_ffc0_0000_0000。如此在虚拟空间执行平移后，就完成到最终目标地址的映射。</li>
</ol>
<img src="./img/img4_4.png" alt="image4_4" style="zoom:50%;" />
<h5 id="代码示例"><a class="header" href="#代码示例">代码示例</a></h5>
<img src="./img/img4_5.png" alt="image4_5" style="zoom:50%;" />
<p>BOOT_PT_SV39使用的是LDS定义布局时，直接预留的一页，所以不用额外内存分配。</p>
<img src="./img/img4_6.png" alt="image4_6" style="zoom:50%;" />
<p>初始化根页表BOOT_PT_SV39，只有一级，即每个页表项直接映射到1G的地址空间。1G = 230 因此pgd_idx = (VA&gt;&gt;30)&amp;(512-1)0x8000_0000 &gt;&gt; 30，对应pgd_idx = 20xffff_ffc0_8000_0000 &gt;&gt; 30，只保留低9位，对应pgd_idx = 0x102物理页帧号 = 物理地址 &gt;&gt; 12，故0x80000。</p>
<h4 id="分页阶段2--重建映射可选"><a class="header" href="#分页阶段2--重建映射可选">分页阶段2 – 重建映射(可选)</a></h4>
<h5 id="机制-1"><a class="header" href="#机制-1">机制</a></h5>
<p>重建映射的意义：</p>
<ol>
<li>管理更大范围的地址空间</li>
<li>分类和权限的粒度控制更加细致</li>
</ol>
<p>BOOT_PT_SV39使用的是LDS定义布局时，直接预留的一页，所以不用额外内存分配。</p>
<img src="./img/img4_7.png" alt="image4_7" style="zoom:50%;" />
<h5 id="代码示例-1"><a class="header" href="#代码示例-1">代码示例</a></h5>
<img src="./img/img4_8.png" alt="image4_8" style="zoom:50%;" />
<h3 id="内存分配"><a class="header" href="#内存分配">内存分配</a></h3>
<h4 id="接口框架与算法"><a class="header" href="#接口框架与算法">接口、框架与算法</a></h4>
<img src="./img/img4_9.png" alt="image4_9" style="zoom:50%;" />
<h4 id="接口和数据结构"><a class="header" href="#接口和数据结构">接口和数据结构</a></h4>
<img src="./img/img4_10.png" alt="image4_10" style="zoom:50%;" />
<h4 id="框架初始化"><a class="header" href="#框架初始化">框架初始化</a></h4>
<img src="./img/img4_11.png" alt="image4_11" style="zoom:50%;" />
<img src="./img/img4_12.png" alt="image4_12" style="zoom:50%;" />
<h4 id="算法组件接口"><a class="header" href="#算法组件接口">算法组件接口</a></h4>
<img src="./img/img4_13.png" alt="image4_13" style="zoom:50%;" />
<img src="./img/img4_14.png" alt="image4_14" style="zoom:50%;" />
<h4 id="内存分配算法"><a class="header" href="#内存分配算法">内存分配算法</a></h4>
<h5 id="tlsf-two-level-segregated-fit"><a class="header" href="#tlsf-two-level-segregated-fit">TLSF (Two-Level Segregated Fit)</a></h5>
<p>两级 bitmap+List 管理空闲块</p>
<p>bitmap 第一级 First Level：每一位对应一个范围的内存块，示例中分别对应24 ~ 231。1表示空闲。图中两个1。</p>
<p>bitmap 第二级 Second Leve：有几位就表示几等分。例如， 2^6^ 表示 64~127，然后进行 4 等分，就是 64~79, 80~95, 96~107, 108~127，每一位对应一个范围，同样1表示空闲。</p>
<p>然后就能找到包含对应范围大小的空闲块链表List。链表耗尽或者新建时，对应维护两级bitmap。</p>
<p><a href="http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf">算法论文链接</a></p>
<img src="./img/img4_15.png" alt="image-20230908163833490" style="zoom:50%;" />
<h5 id="buddy"><a class="header" href="#buddy">Buddy</a></h5>
<p>分配单元 Unit：一般不会采用1字节，通常8，16，32…字节。</p>
<p>分配：寻找匹配 alloc 需要（order）的最小块如果 order 大于目标，则二分切割，直至相等，每级剩余的部分挂到对应的 Order List；</p>
<p>释放：查看是否有邻居空闲块，有则尽可能向高 Oder 合并，直至无法合并，挂到 OrderList。</p>
<img src="./img/img4_16.png" alt="image-20230908164413949" style="zoom:50%;" />
<h5 id="slab"><a class="header" href="#slab">Slab</a></h5>
<p>结构：</p>
<ol>
<li>通过OrderList维护一系列Slab</li>
<li>Slab维持一个空闲的block链表</li>
</ol>
<p>分配：</p>
<p>从block空闲链表中弹出一个block。依靠BuddyAllocator提供内存分配支持，初始时以及block不足时，从BuddyAllocator申请，分割block后加入block空闲链表。</p>
<p>释放：</p>
<p>放回block空闲链表。</p>
<img src="./img/img4_17.png" alt="image-20230908164609352" style="zoom:50%;" />
<h3 id="附录-相关组件-1"><a class="header" href="#附录-相关组件-1">附录 相关组件</a></h3>
<ul>
<li>
<h4 id="allocator-"><a class="header" href="#allocator-"><code>allocator</code> ：</a></h4>
<ul>
<li>模块源码位置：<a href="https://github.com/rcore-os/arceos/tree/main/crates/allocator">crates/allocator</a></li>
<li>模块描述： <code>allocator</code> 模块提供了一个统一的接口，用于实现不同类型的内存分配器算法。该模块共包括三种不同类型的分配器：字节粒度内存分配器 (<code>ByteAllocator</code>)、页粒度内存分配器 (<code>PageAllocator</code>) 和唯一 ID 分配器 (<code>IdAllocator</code>)。每种分配器都有其特定的实现方式，例如 <code>BuddyByteAllocator</code> 和 <code>SlabByteAllocator</code> 对应的是字节粒度内存分配器，而 <code>BitmapPageAllocator</code> 对应的是页粒度内存分配器。这个模块使得不同的内存分配器可以更加灵活地组合和替换，实现更加高效和可靠的内存管理功能。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="本章实践与总结-1"><a class="header" href="#本章实践与总结-1">本章实践与总结</a></h2>
<h3 id="练习-1"><a class="header" href="#练习-1">练习</a></h3>
<p>待完善</p>
<h3 id="实验-1"><a class="header" href="#实验-1">实验</a></h3>
<p>题目：针对字节内存分配，增加一个新的内存分配算法</p>
<p>要求：只能修改 crates/allocator/src/simple.rs，修改其中的数据结构和填充相关函数，执行 verify 脚本验证 a1 通过。</p>
<p>提示：</p>
<ol>
<li>可以参考现有的 tlsf，slab 等算法；或者其它了解的算法。</li>
<li>提供一个 Bump 算法(最简版本)，供参考。
<ul>
<li>关键数据成员: next 指针总是指向空闲区开始位置，计数 allocations 记录已经分配的次数；</li>
<li>申请内存: 移动 next 位置指针， allocations 加一，返回移动前的 next；</li>
<li>释放内存: allocations 减一。如果归零，复位 next 到起始位置；</li>
<li>需要检查，分配和释放是否越界。</li>
</ul>
</li>
</ol>
<img src="./img/img4_18.png" alt="image-20230908165138488" style="zoom:50%;" />
<h3 id="总结-1"><a class="header" href="#总结-1">总结</a></h3>
<p>v0.2 内存管理框架与功能：</p>
<ol>
<li>
<p>内存分配功能</p>
<ul>
<li>内含两类分配器，字节分配器和页分配器；</li>
<li>框架与算法分离，松耦合支持多种内存分配算法。</li>
</ul>
</li>
<li>
<p>分页功能</p>
</li>
</ol>
<p>启动早期基于静态恒等映射完成分页切换，如果指定 paging feature 则会在启动后期重新建立范围更大，权限控制更细的映射。</p>
<img src="./img/img4_19.png" alt="image-20230908165439924" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h2 id="任务调度"><a class="header" href="#任务调度">任务调度</a></h2>
<h3 id="目标-2"><a class="header" href="#目标-2">目标</a></h3>
<ol>
<li>任务和任务状态</li>
<li>通用调度框架和初始化</li>
<li>系统内置任务idle, main和gc</li>
<li>协作式调度机制和示例</li>
<li>抢占式调度与协作式区别</li>
<li>抢占式调度框架实现</li>
<li>抢占式调度算法：sched_rr &amp; sched_cfs</li>
</ol>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p><strong>任务：</strong> 被调度的对象，具有独立工作逻辑。</p>
<p><strong>调度：</strong> 资源相对于使用者通常是不足的，调度就是用来协调每个请求对资源的使用的方法。</p>
<p><strong>任务调度：</strong> 协调可执行任务对 CPU资源 的使用。</p>
<p><strong>协作式调度：</strong> 任务之间通过“友好”协作方式分享CPU资源。具体的，当前任务是否让出和何时让出CPU控制权完全由当前任务自己决定。</p>
<p><strong>抢占式调度：</strong> 调度器依据策略，可以打断当前任务的执行，移交CPU执行权给当前“更”有资格 的任务。抢占机制的根本保障是系统定时器。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="51-建立通用调度框架"><a class="header" href="#51-建立通用调度框架">5.1 建立通用调度框架</a></h2>
<h3 id="511-任务"><a class="header" href="#511-任务">5.1.1 任务</a></h3>
<h4 id="一任务状态"><a class="header" href="#一任务状态">一、任务状态</a></h4>
<p><img src="img/img5_1.png" alt="image-20230911094606238" /></p>
<h4 id="二任务数据结构"><a class="header" href="#二任务数据结构">二、任务数据结构</a></h4>
<img src="./img/img5_2.png" alt="image-20230911094724468" style="zoom:50%;" />
<h3 id="512-通用调度框架和初始化"><a class="header" href="#512-通用调度框架和初始化">5.1.2 通用调度框架和初始化</a></h3>
<h4 id="一通用调度框架"><a class="header" href="#一通用调度框架">一、通用调度框架</a></h4>
<p>框架支持协作式和抢占式调度。其中，标红的两处：</p>
<ul>
<li>当前任务是操作的焦点；</li>
<li>TaskContext.switch_to 是任务切换的关键。</li>
</ul>
<img src="./img/img5_3.png" alt="image-20230911095148916" style="zoom:50%;" />
<h4 id="二接口---主要调度api"><a class="header" href="#二接口---主要调度api">二、接口 - 主要调度API</a></h4>
<p>接口公开的是 runqueue 的对应方法：</p>
<ul>
<li>spawn&amp;spawn_raw：产生一个新任务，加入 runqueue，处于 Ready；</li>
<li>yield_now (协作式调度的关键)：主动让出 CPU 执行权；</li>
<li>sleep&amp;sleep_until：(1)睡眠固定的时间后醒来；(2)在 timers 定时器列表中注册，等待唤醒；</li>
<li>exit：当前任务退出，标记状态，等待 GC 回收。</li>
</ul>
<h4 id="三调度框架初始化"><a class="header" href="#三调度框架初始化">三、调度框架初始化</a></h4>
<img src="./img/img5_4.png" alt="image-20230911100020690" style="zoom:50%;" />
<h4 id="四核心算法context_switch"><a class="header" href="#四核心算法context_switch">四、核心算法：context_switch</a></h4>
<p>任务上下文 Context：保存任务状态的最小的寄存器状态集合。</p>
<p>下图是理解上下文切换的两个角度：</p>
<img src="./img/img5_5.png" alt="image-20230911100211501" style="zoom:50%;" />
<h4 id="五上下文-context-包含寄存器"><a class="header" href="#五上下文-context-包含寄存器">五、上下文 Context 包含寄存器:</a></h4>
<ul>
<li>ra:：函数返回地址寄存器，这个切换实现了任务执行指令流的切换；</li>
<li>sp：任务即线程，这个是线程栈；</li>
<li>s0~s11：按照 riscv 规范，callee 不能改这组寄存器的信息，所以需要保存。</li>
</ul>
<img src="./img/img5_6.png" alt="image-20230911100633263" style="zoom:50%;" />
<h3 id="513-系统内置任务idle-main和gc"><a class="header" href="#513-系统内置任务idle-main和gc">5.1.3 系统内置任务idle, main和gc</a></h3>
<img src="./img/img5_7.png" alt="image-20230911101154789" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h2 id="52-协作式调度机制与示例"><a class="header" href="#52-协作式调度机制与示例">5.2 协作式调度机制与示例</a></h2>
<h3 id="521-协作式调度算法-fifo-机制"><a class="header" href="#521-协作式调度算法-fifo-机制">5.2.1 协作式调度算法 FIFO 机制</a></h3>
<ul>
<li>
<p>任务按照先入先出的顺序被 CPU 执行；</p>
</li>
<li>
<p>当前任务一旦获得执行权，就会一直执行；</p>
</li>
<li>
<p>只有两种情况下，其它任务才能获得执行机会：</p>
<ul>
<li>
<p>当前任务执行完成后退出；</p>
</li>
<li>
<p>当前任务主动调用 yield_now 让出执行权。</p>
</li>
</ul>
</li>
</ul>
<img src="./img/img5_8.png" alt="image-20230911105017007" style="zoom:50%;" />
<h3 id="522-协作式调度算法fifo实现"><a class="header" href="#522-协作式调度算法fifo实现">5.2.2 协作式调度算法FIFO实现</a></h3>
<img src="./img/img5_9.png" alt="image-20230911105143268" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h2 id="53-抢占式调度机制与示例"><a class="header" href="#53-抢占式调度机制与示例">5.3 抢占式调度机制与示例</a></h2>
<h3 id="531-抢占式调度与协作式在框架上的区别"><a class="header" href="#531-抢占式调度与协作式在框架上的区别">5.3.1 抢占式调度与协作式在框架上的区别</a></h3>
<p>抢占式调度在协作式自主 yield 的基础上，通过加入时钟中断，确保个别任务不会长期不合理的占据 CPU。</p>
<img src="./img/img5_10.png" alt="image-20230911105410138" style="zoom:50%;" />
<h3 id="532-时钟中断与抢占式调度"><a class="header" href="#532-时钟中断与抢占式调度">5.3.2 时钟中断与抢占式调度</a></h3>
<img src="./img/img5_11.png" alt="image-20230911105602764" style="zoom:50%;" />
<h3 id="533-抢占式调度算法-round_robin"><a class="header" href="#533-抢占式调度算法-round_robin">5.3.3 抢占式调度算法 ROUND_ROBIN</a></h3>
<p>在协作式调度 FIFO 的基础上，由定时器定时递减<font color=red>当前任务</font>的时间片，耗尽时排到队尾，如此完成各个任务的循环排列。</p>
<blockquote>
<p><font color=blue><strong>注👉</strong></font> 
注意，各个 scheduler 操作的核心目标都是当前任务。</p>
</blockquote>
<img src="./img/img5_12.png" alt="image-20230911105814589" style="zoom:50%;" />
<img src="./img/img5_13.png" alt="image-20230911110533751" style="zoom:50%;" />
<h3 id="534-抢占式调度算法-cfscompletely-fair-scheduler"><a class="header" href="#534-抢占式调度算法-cfscompletely-fair-scheduler">5.3.4 抢占式调度算法 CFS(Completely Fair Scheduler)</a></h3>
<p>当前 vruntime 最小的任务就是当前任务。计算公式：
$$
vruntime = init_vruntime + (delta / weight(nice))
$$
系统初始化时，init_vruntime, delta, nice 三者都是 0</p>
<img src="./img/img5_14.png" alt="image-20230911110718949" style="zoom:50%;" />
<img src="./img/img5_15.png" alt="image-20230911110817258" style="zoom:50%;" />
<img src="./img/img5_16.png" alt="image-20230911110905924" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h1 id="54-本章实践与总结"><a class="header" href="#54-本章实践与总结">5.4 本章实践与总结</a></h1>
<h3 id="541-练习"><a class="header" href="#541-练习">5.4.1 练习</a></h3>
<p>待完善</p>
<h3 id="542-实验"><a class="header" href="#542-实验">5.4.2 实验</a></h3>
<h4 id="实验1"><a class="header" href="#实验1">实验1</a></h4>
<p>题目：把协作式调度算法改造为抢占式调度算法。</p>
<p>要求：只能修改 crates/scheduler/src/simple.rs，修改其中的数据结构和填充相关函数，执行 verify 脚本验证通过。</p>
<p>提示：</p>
<ul>
<li>可以参考现有的 sched_rr 或 sched_cfs 等算法；或者其它了解的算法。</li>
<li>重点是发挥 task_tick 方法的作用。</li>
</ul>
<h4 id="实验2"><a class="header" href="#实验2">实验2</a></h4>
<p>题目：支持 ramfs 的 rename 操作。</p>
<p>要求：只能修改 crates/axfs_ramfs/src/dir.rs，增加相关函数，实现部分 trait，执行 verify 脚本验证通过。</p>
<p>提示：无</p>
<h3 id="543-总结"><a class="header" href="#543-总结">5.4.3 总结</a></h3>
<p>通过本章学习，建立了基础的调度框架，引入三个系统任务辅助任务管理。目前可以基于最简单的协作式和抢占式调度算法，支持多任务。</p>
<blockquote>
<p><font color=blue><strong>注👉</strong></font></p>
<p>注意，ArceOS 的抢占式调度与 Linux 所说的”抢占”有概念上的区别。</p>
</blockquote>
<img src="./img/img5_17.png" alt="image-20230911113912689" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h2 id="设备与驱动"><a class="header" href="#设备与驱动">设备与驱动</a></h2>
<h3 id="目标-3"><a class="header" href="#目标-3">目标</a></h3>
<ol>
<li>设备管理结构</li>
<li>设备发现与初始化</li>
<li>中断机制与初始化</li>
</ol>
<img src="./img/img6_1.png" alt="image-20230911144552390" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h2 id="设计与实现-2"><a class="header" href="#设计与实现-2">设计与实现</a></h2>
<h3 id="设备管理框架"><a class="header" href="#设备管理框架">设备管理框架</a></h3>
<p>AllDevices 管理系统所有的设备，为上层的子系统如文件系统 FS、网络协议栈 NET 提供访问服务。</p>
<p>三种设备类型：</p>
<img src="./img/img6_2.png" alt="image-20230911145019737" style="zoom:50%;" />
<h3 id="设备发现与初始化过程"><a class="header" href="#设备发现与初始化过程">设备发现与初始化过程</a></h3>
<img src="./img/img6_3.png" alt="image-20230911145131833" style="zoom:50%;" />
<h4 id="基于总线发现设备--qemu-平台示例"><a class="header" href="#基于总线发现设备--qemu-平台示例">基于总线发现设备- qemu 平台示例</a></h4>
<img src="./img/img6_4.png" alt="image-20230911145250416" style="zoom:50%;" />
<h4 id="virtio-设备的-probe-过程"><a class="header" href="#virtio-设备的-probe-过程">virtio 设备的 probe 过程</a></h4>
<ol>
<li>
<p>qemu 模拟器基于命令行产生设备：</p>
<pre><code>-device virtio-blk-device,drive=disk0
-drive id=disk0,format=raw,file=disk.img
</code></pre>
</li>
<li>
<p>qemu 将设备 mmio 地址区域映射到 Guest 中；</p>
<p>qemu-virt 平台默认有 8 个区域槽位，通常只有部分会形成映射，其它处于未映射状态，即表现为空设备；</p>
</li>
<li>
<p>virtio-mmio 驱动逐个发请求区探查这些区域槽位；</p>
<ul>
<li>对应映射设备响应请求，返回本设备的类型 ID；</li>
<li>没有映射的槽位返回零，表示空设备。</li>
</ul>
</li>
<li>
<p>virtio-mmio 驱动把 probe 结果报告上层。</p>
</li>
</ol>
<img src="./img/img6_5.png" alt="image-20230911145802450" style="zoom:50%;" />
<h4 id="virtio-驱动基本模型"><a class="header" href="#virtio-驱动基本模型">virtio 驱动基本模型</a></h4>
<p>virtio 驱动和 virtio 设备交互的两条路：</p>
<ol>
<li>主要基于 vring 环形队列：本质上是连续的 Page 页面，在 Guest 和 Host 都可见可写；</li>
<li>中断响应的通道：主要对等待读取大块数据时是有用。</li>
</ol>
<img src="./img/img6_6.png" alt="image-20230911150030496" style="zoom:50%;" />
<h3 id="中断机制与初始化以-riscv64-为例"><a class="header" href="#中断机制与初始化以-riscv64-为例">中断机制与初始化（以 riscv64 为例）</a></h3>
<img src="./img/img6_7.png" alt="image-20230911150146713" style="zoom:50%;" />
<h3 id="块设备驱动---blockdriver"><a class="header" href="#块设备驱动---blockdriver">块设备驱动 - BlockDriver</a></h3>
<img src="./img/img6_8.png" alt="image-20230911151439938" style="zoom:50%;" />
<h4 id="块设备驱动-trait---blockdriverops"><a class="header" href="#块设备驱动-trait---blockdriverops">块设备驱动 Trait - BlockDriverOps</a></h4>
<img src="./img/img6_9.png" alt="image-20230911151607819" style="zoom: 50%;" />
<div style="break-before: page; page-break-before: always;"></div><h2 id="本章实践与总结-2"><a class="header" href="#本章实践与总结-2">本章实践与总结</a></h2>
<h3 id="练习-2"><a class="header" href="#练习-2">练习</a></h3>
<p>待完善</p>
<h3 id="实验-2"><a class="header" href="#实验-2">实验</a></h3>
<p>待完善</p>
<h3 id="总结-2"><a class="header" href="#总结-2">总结</a></h3>
<p>待完善</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第七章-文件系统"><a class="header" href="#第七章-文件系统">第七章 文件系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="设计与实现-3"><a class="header" href="#设计与实现-3">设计与实现</a></h2>
<h3 id="文件系统---filesystem"><a class="header" href="#文件系统---filesystem">文件系统 - FileSystem</a></h3>
<img src="./img/img6_10.png" alt="image-20230911151734593" style="zoom:50%;" />
<h3 id="文件系统的抽象与对应数据结构"><a class="header" href="#文件系统的抽象与对应数据结构">文件系统的抽象与对应数据结构</a></h3>
<img src="./img/img6_11.png" alt="image-20230911151843644" style="zoom:50%;" />
<h3 id="文件系统节点的操作流程"><a class="header" href="#文件系统节点的操作流程">文件系统节点的操作流程</a></h3>
<p>第一步：获得 Root 目录节点；</p>
<p>第二步：解析路径，逐级通过 lookup 方法找到对应节点，直至目标节点；</p>
<p>第三步：对目标节点执行操作。</p>
<img src="./img/img6_12.png" alt="image-20230911151956473" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h2 id="本章实践与总结-3"><a class="header" href="#本章实践与总结-3">本章实践与总结</a></h2>
<h3 id="练习-3"><a class="header" href="#练习-3">练习</a></h3>
<p>待完善</p>
<h3 id="实验-3"><a class="header" href="#实验-3">实验</a></h3>
<p>待完善</p>
<h3 id="总结-3"><a class="header" href="#总结-3">总结</a></h3>
<p>待完善</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第八章-网络"><a class="header" href="#第八章-网络">第八章 网络</a></h1>
<h3 id="目标-4"><a class="header" href="#目标-4">目标</a></h3>
<img src="./img/img8_1.png" alt="image-20230911154129054" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计与实现-4"><a class="header" href="#设计与实现-4">设计与实现</a></h1>
<h3 id="网卡过滤驱动"><a class="header" href="#网卡过滤驱动">网卡过滤驱动</a></h3>
<p>在驱动链中插入一级驱动，向上提供与下层一致的接口，向下为上层传递请求。通常作为安全用途：监控、审计甚至阻断。</p>
<img src="./img/img8_2.png" alt="image-20230911154302824" style="zoom:50%;" />
<h3 id="网络协议栈---net"><a class="header" href="#网络协议栈---net">网络协议栈 - NET</a></h3>
<p>目前基于对 smoltcp 的封装。</p>
<img src="./img/img8_3.png" alt="image-20230911154407174" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h1 id="本章实践与总结-4"><a class="header" href="#本章实践与总结-4">本章实践与总结</a></h1>
<h3 id="练习-4"><a class="header" href="#练习-4">练习</a></h3>
<p>待完善</p>
<h3 id="实验-4"><a class="header" href="#实验-4">实验</a></h3>
<p>题目：实现针对 virtio-net 驱动的过滤驱动，监控发送和接受的数据包。</p>
<p>要求：只能修改 modules/axdriver/src/filter.rs，执行 verify 脚本验证通过。并且屏幕输出如下：</p>
<img src="./img/img8_4.png" alt="image-20230911154543778" style="zoom:50%;" />
<p>提示：
过滤驱动用 warn! 打印监控到的收发数据。</p>
<ul>
<li>
<p>对 transmit</p>
<pre><code>warn!(&quot;Filter: transmit len[{}]&quot;, ptr.packet_len());
</code></pre>
</li>
<li>
<p>对 receive</p>
<pre><code>warn!(&quot;Filter: receive len[{:?}]&quot;, b.packet_len());
</code></pre>
</li>
</ul>
<h3 id="总结-4"><a class="header" href="#总结-4">总结</a></h3>
<p>待完善</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第九章-应用支持库--axstd--axlibc"><a class="header" href="#第九章-应用支持库--axstd--axlibc">第九章 应用支持库- axstd &amp; axlibc</a></h1>
<p>支持 Rust 和 C 两种应用库。</p>
<img src="./img/img9_1.png" alt="image-20230911155700423" style="zoom:50%;" />
<h3 id="rust-库---axstd"><a class="header" href="#rust-库---axstd">Rust 库 - axstd</a></h3>
<p>参照官方 Std 的接口及目录设置，用 ArceOS 对应的功能匹配。</p>
<img src="./img/img9_2.png" alt="image-20230911155743683" style="zoom:50%;" />
<h3 id="c-库---axlibc"><a class="header" href="#c-库---axlibc">C 库 - axlibc</a></h3>
<p>首先把 ArceOS 主体编译为静态库，最后与应用以及 axlib 完成链接。</p>
<img src="./img/img9_3.png" alt="image-20230911155842279" style="zoom:50%;" />
<h3 id="axstd--axlibc-方式的对比"><a class="header" href="#axstd--axlibc-方式的对比">axstd &amp; axlibc 方式的对比</a></h3>
<img src="./img/img9_4.png" alt="image-20230911155928415" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十章-多核支持---smp"><a class="header" href="#第十章-多核支持---smp">第十章 多核支持 - SMP</a></h1>
<p>多个 CPU (核)共享同一个任务调度队列，实现任务并发执行。SpinLock 自旋锁对任务队列提供互斥保护。</p>
<img src="./img/img10_1.png" alt="image-20230911161008055" style="zoom:50%;" />
<h3 id="percpu-作用"><a class="header" href="#percpu-作用">PerCPU 作用</a></h3>
<p>专属于 CPU 的本地存储区域，获得更高的本地缓存效率。</p>
<p>类比：</p>
<ul>
<li>TLS: thread-local-storage</li>
<li>PerCPU: cpu-local-storage</li>
</ul>
<img src="./img/img10_2.png" alt="image-20230911161148978" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h1 id="第十一章-总结和展望"><a class="header" href="#第十一章-总结和展望">第十一章 总结和展望</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计思想"><a class="header" href="#设计思想">设计思想</a></h1>
<h3 id="组件化方法构造-os"><a class="header" href="#组件化方法构造-os">组件化方法构造 OS</a></h3>
<p>以组件库为基础，通过组合组件方式构造各种特性的 OS。即研究一种基于组件构造 OS 的&quot;工厂式&quot;方法。</p>
<img src="./img/img11_1.png" alt="image-20230911161455096" style="zoom:50%;" />
<h3 id="操作系统相关与无关"><a class="header" href="#操作系统相关与无关">操作系统相关与无关</a></h3>
<img src="./img/img11_2.png" alt="image-20230911161542372" style="zoom:50%;" />
<h3 id="主干组件与功能组件"><a class="header" href="#主干组件与功能组件">主干组件与功能组件</a></h3>
<ol>
<li>
<p>通过横向对比各种 OS 实现</p>
<ul>
<li>区分共性的部分和个性的部分</li>
<li>区分相对固定的部分和相对易变的部分</li>
</ul>
<p>共性固定是主干框架；个性易变是功能组件</p>
</li>
<li>
<p>主干框架</p>
<ul>
<li>主干组件：按照执行顺序切分为一系列阶段，并且应当是各种 OS 框架的最大集合。每个阶段根据情况对应有效主干组件或者是空实现组件。</li>
<li>主干组件决定干什么？它们根据策略在功能组件中选择适当组件去完成工作。</li>
</ul>
</li>
<li>
<p>功能组件</p>
<ul>
<li>功能组件决定怎么干?</li>
<li>同一功能组中的各个组件是互备关系，可以互相替换。</li>
</ul>
</li>
</ol>
<img src="./img/img11_3.png" alt="image-20230911162523660" style="zoom:50%;" />
<h3 id="面向应用"><a class="header" href="#面向应用">面向应用</a></h3>
<ol>
<li>以应用为中心：整个系统服务于应用和支撑应用；</li>
<li>依赖组件集合最小化：满足应用运行前提下，无冗余组件。</li>
</ol>
<img src="./img/img11_4.png" alt="image-20230911162656680" style="zoom:50%;" />
<h3 id="构造过程脚本和测试"><a class="header" href="#构造过程脚本和测试">构造过程、脚本和测试</a></h3>
<img src="./img/img11_5.png" alt="image-20230911162820264" style="zoom:50%;" />
<div style="break-before: page; page-break-before: always;"></div><h1 id="未来发展"><a class="header" href="#未来发展">未来发展</a></h1>
<h3 id="异步"><a class="header" href="#异步">异步</a></h3>
<h4 id="研究的基础"><a class="header" href="#研究的基础"><strong>研究的基础</strong></a></h4>
<ol>
<li>IO 密集型是 AIoT 的典型场景，最适合采用异步</li>
<li>ArceOS 是应用为中心的 UniKernel OS，相对 Linux 等通用宏内核或微内核，其专用性更适应AIoT 特点</li>
<li>Rust语言级支持异步，即 async/await</li>
</ol>
<h4 id="研究的意义"><a class="header" href="#研究的意义">研究的意义</a></h4>
<p>面向 AIoT 的 IO 密集型场景，以组件化方式构建以应用为中心的 UniKernel OS，并发挥 Rust 对异步的内置支持能力。这种方案有可能比基于传统 OS 建立的方案，具有更高的运行效率和更小的Image。</p>
<h4 id="需要解决的问题"><a class="header" href="#需要解决的问题">需要解决的问题</a></h4>
<ol>
<li>Tokio 本身的改造，提升协程与线程的协作效率；</li>
<li>Rust 标准库支持 ArceOS 后端，编译时支持 ArceOS 这个 Target；</li>
<li>改造 mio&amp;socket2，支持 ArceOS 后端；</li>
<li>改造网络协议栈这个组件，提升并发性；</li>
<li>实现硬件平台驱动，重点支持 10G 网卡和中断。</li>
</ol>
<img src="./img/img11_6.png" alt="image-20230911163527473" style="zoom:50%;" />
<p>异步环境下，存在两类调度实体：</p>
<ol>
<li>协程(tokio 中称 task)，基于 Rust 语言的异步特性 async/await，有专门的 task 调度。</li>
<li>线程，即 OS 的线程。负责执行若干个 task 协程。并且具有特定条件下，steal task 的能力。</li>
</ol>
<p><img src="./img/img11_7.png" alt="image-20230911163826826" /></p>
<h4 id="研究目标"><a class="header" href="#研究目标">研究目标</a></h4>
<p>在 ArceOS 平台上，协程与线程的高效协同。涉及调度策略、协程锁与线程锁，消息交换和共享等优化。</p>
<h3 id="平台移植"><a class="header" href="#平台移植">平台移植</a></h3>
<p>树莓派 arm 平台的移植参考。arm 体系结构已存在，基本不用改；platform 增加对应目录，大部分代码可复用 aarch64_common 中内容。</p>
<img src="./img/img11_8.png" alt="image-20230911163926101" style="zoom:50%;" />
<h3 id="宏内核微内核"><a class="header" href="#宏内核微内核">宏内核/微内核</a></h3>
<ol>
<li>从单地址空间到多地址空间；</li>
<li>从单内核态到内核态+用户态；</li>
<li>引入系统调用层以及进程相关的功能。</li>
</ol>
<img src="./img/img11_9.png" alt="image-20230911164331843" style="zoom:50%;" />
<h3 id="研究全景图"><a class="header" href="#研究全景图">研究全景图</a></h3>
<img src="./img/img11_10.png" alt="image-20230911164426556" style="zoom:50%;" />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
